# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IsssGuMVhRPL9l4skXLkncZtRjIxfMSa
"""



import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
import tensorflow as tf
from tensorflow import keras

# Load and preprocess the data
tf.random.set_seed(42)

# Load data from CSV files
supine_data = pd.read_csv("supine.csv", header=None, names=['x', 'y', 'z'])
prone_data = pd.read_csv("prone.csv", header=None, names=['x', 'y', 'z'])
side_data = pd.read_csv("side.csv", header=None, names=['x', 'y', 'z'])
sitting_data = pd.read_csv("sitting.csv", header=None, names=['x', 'y', 'z'])
unknown_data = pd.read_csv("unknown.csv", header=None, names=['x', 'y', 'z'])

# Assign class labels
supine_data["label"] = 1
prone_data["label"] = 2
side_data["label"] = 3  # Labeled as 3 for both rightside and leftside combined
sitting_data["label"] = 4
unknown_data["label"] = 5

# Combine all data into one dataframe
combined_data = pd.concat([supine_data, prone_data, side_data, sitting_data, unknown_data], ignore_index=True, axis=0)

# Shuffle the data
combined_data = combined_data.sample(frac=1, random_state=42).reset_index(drop=True)

# Fill missing values with 0 (you can modify this based on your data)
combined_data = combined_data.fillna(0)

# Encode class labels
label_encoder = LabelEncoder()
combined_data["label"] = label_encoder.fit_transform(combined_data["label"])

# Split the dataset into training, validation, and test sets
train_data, test_data = train_test_split(combined_data, test_size=0.2, random_state=42, stratify=combined_data["label"])
train_data, val_data = train_test_split(train_data, test_size=0.1, random_state=42, stratify=train_data["label"])

# Separate features and labels
X_train = train_data.drop(columns=["label"]).values
y_train = train_data["label"].values
X_val = val_data.drop(columns=["label"]).values
y_val = val_data["label"].values
X_test = test_data.drop(columns=["label"]).values
y_test = test_data["label"].values

# Reshape data for CNN (add a channel dimension)
X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)
X_val = X_val.reshape(X_val.shape[0], X_val.shape[1], 1)
X_test = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)

model = keras.Sequential([
    keras.layers.Conv1D(filters=32, kernel_size=3, activation='relu', input_shape=(X_train.shape[1], 1)),
    keras.layers.MaxPooling1D(pool_size=1),  # Reduce the pool size
    keras.layers.Flatten(),
    keras.layers.Dense(64, activation='relu'),
    keras.layers.Dense(5, activation='softmax')
])

# Compile the model
model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Train the model
history = model.fit(X_train, y_train, validation_data=(X_val, y_val), epochs=50, batch_size=32, verbose=2)

# Evaluate the model on the test set
test_loss, test_accuracy = model.evaluate(X_test, y_test, verbose=2)
print(f"Test Loss: {test_loss}, Test Accuracy: {test_accuracy}")

# Save the model
model.save("posture_detection_cnn_model")

# Convert the model to TFLite format
converter = tf.lite.TFLiteConverter.from_keras_model(model)
tflite_model = converter.convert()

# Save the TFLite model to a file
with open('model.tflite', 'wb') as f:
    f.write(tflite_model)